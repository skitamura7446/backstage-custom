"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var deep_equal_1 = __importDefault(require("deep-equal"));
var Either_1 = require("fp-ts/lib/Either");
var t = __importStar(require("io-ts"));
var PathReporter_1 = require("io-ts/lib/PathReporter");
function decode(type, value) {
    switch (arguments.length) {
        case 0:
            throw new Error('Function called with no arguments');
        case 1:
            return decode.bind(null, type);
        default:
            return Either_1.fold(function (errors) { return Promise.reject(new DecodeError(errors)); }, function (decodedValue) { return Promise.resolve(decodedValue); })(type.decode(value || arguments[1]));
    }
}
exports.decode = decode;
/**
 * Checks whether error was produced by @see decode due to invalid data.
 */
function isDecodeError(error) {
    return error instanceof DecodeError;
}
exports.isDecodeError = isDecodeError;
/**
 * Custom error class which is rejected by the @see decode function
 * when decoding fails due to invalid data.
 */
var DecodeError = /** @class */ (function (_super) {
    __extends(DecodeError, _super);
    function DecodeError(errors) {
        var _this = _super.call(this, PathReporter_1.PathReporter.report(t.failures(errors)).join('\n')) || this;
        _this.name = 'DecodeError';
        _this.errors = errors;
        Object.setPrototypeOf(_this, DecodeError.prototype);
        return _this;
    }
    return DecodeError;
}(Error));
exports.DecodeError = DecodeError;
/**
 * Creates a new io-ts type from given decode and encode functions.
 *
 * @param decode Function that transforms unknown values to desired type,
 *               or throws an error if the tranformation is not supported.
 * @param encode Function that transforms decoded values back to the original encoded format.
 * @param name Optional name of the type, making decoding errors more informative.
 */
function createType(decode, encode, name) {
    return extendType(t.unknown, decode, encode, name);
}
exports.createType = createType;
/**
 * Extends an existing io-ts type, mapping the output value using the decode and encode functions.
 *
 * @param baseType The io-ts type to extend.
 * @param decode Function to transform output of `baseType` to desired value,
 *               or throws an error if the transformation is not supported.
 * @param encode Function to transform decoded type to back to `baseType` output.
 * @param name Optional name of the type, making decoding errors more informative.
 */
function extendType(baseType, decode, encode, name) {
    var extendedDecoder = extendDecoder(baseType, decode);
    var typeIs = function (value) {
        try {
            var inputValue = encode(value);
            if (!baseType.is(inputValue)) {
                return false;
            }
            var decodedValue = decode(inputValue);
            return deep_equal_1.default(value, decodedValue, { strict: true });
        }
        catch (_a) {
            return false;
        }
    };
    var typeEncode = function (outputValue) {
        return baseType.encode(encode(outputValue));
    };
    return new t.Type(name || extendedDecoder.name, typeIs, extendedDecoder.validate, typeEncode);
}
exports.extendType = extendType;
/**
 * Creates a new decoder from decode and function.
 *
 * @param decode Function that transforms unknown values to desired type,
 *               or throws an error if the tranformation is not supported.
 * @param name Optional name of the type, making decoding errors more informative.
 */
function createDecoder(decode, name) {
    return extendDecoder(t.unknown, decode, name);
}
exports.createDecoder = createDecoder;
/**
 * Extends an existing decoder, or io-ts type, mapping the output value using the decode function.
 *
 * @param baseDecoder The decoder, or io-ts type, to extend.
 * @param decode Function to transform output of `baseDecoder` to desired value,
 *               or throws an error if the transformation is not supported.
 * @param name Optional name of the type, making decoding errors more informative.
 */
function extendDecoder(baseDecoder, decode, name) {
    var validate = function (value, context) {
        return Either_1.either.chain(baseDecoder.validate(value, context), function (chainedValue) {
            try {
                return t.success(decode(chainedValue));
            }
            catch (e) {
                return t.failure(value, context, e);
            }
        });
    };
    return new Decoder(name || baseDecoder.name + "Extended", validate);
}
exports.extendDecoder = extendDecoder;
/**
 * Helper class implementing the Decoder intrface defined in io-ts.
 */
var Decoder = /** @class */ (function (_super) {
    __extends(Decoder, _super);
    function Decoder(name, validate) {
        return _super.call(this, name, Decoder.is, validate, Decoder.encode) || this;
    }
    Decoder.is = function (_) {
        throw new Error('Is is not implemented in a decoder');
    };
    Decoder.encode = function () {
        throw new Error('Encode is not implemented in a decoder');
    };
    return Decoder;
}(t.Type));
