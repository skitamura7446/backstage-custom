import * as _backstage_core_components from '@backstage/core-components';
import * as _backstage_catalog_model from '@backstage/catalog-model';
import { Entity } from '@backstage/catalog-model';
import * as _backstage_core_plugin_api from '@backstage/core-plugin-api';
import { DiscoveryApi, IdentityApi } from '@backstage/core-plugin-api';
import * as t from 'io-ts';
import { Type } from 'io-ts';

declare const argocdPlugin: _backstage_core_plugin_api.BackstagePlugin<{
    entityContent: _backstage_core_plugin_api.RouteRef<undefined>;
}, {}, {}>;
declare const EntityArgoCDContent: () => JSX.Element;
declare const EntityArgoCDOverviewCard: (props: {
    entity?: _backstage_catalog_model.Entity | undefined;
    extraColumns?: _backstage_core_components.TableColumn<{}>[] | undefined;
}) => JSX.Element;
declare const EntityArgoCDHistoryCard: () => JSX.Element;

declare const argoCDAppDeployRevisionDetails: t.TypeC<{
    author: t.UnionC<[t.StringC, t.UndefinedC]>;
    date: t.UnionC<[t.StringC, t.UndefinedC]>;
    message: t.UnionC<[t.StringC, t.UndefinedC]>;
}>;
declare const argoCDAppDetails: t.TypeC<{
    metadata: t.TypeC<{
        name: t.StringC;
        namespace: t.StringC;
        instance: t.UnionC<[t.TypeC<{
            name: t.UnionC<[t.StringC, t.UndefinedC]>;
            url: t.UnionC<[t.StringC, t.UndefinedC]>;
        }>, t.UndefinedC]>;
    }>;
    status: t.TypeC<{
        sync: t.TypeC<{
            status: t.StringC;
        }>;
        health: t.TypeC<{
            status: t.StringC;
        }>;
        operationState: t.UnionC<[t.TypeC<{
            startedAt: t.StringC;
            finishedAt: t.UnionC<[t.StringC, t.UndefinedC]>;
        }>, t.UndefinedC]>;
        history: t.UnionC<[t.ArrayC<t.TypeC<{
            id: t.UnionC<[t.NumberC, t.UndefinedC]>;
            revision: t.UnionC<[t.TypeC<{
                revisionID: t.UnionC<[t.NumberC, t.UndefinedC]>;
                author: t.UnionC<[t.NumberC, t.UndefinedC]>;
                date: t.UnionC<[t.StringC, t.UndefinedC]>;
                message: t.UnionC<[t.StringC, t.UndefinedC]>;
            }>, t.UndefinedC, t.StringC]>;
            deployStartedAt: t.UnionC<[t.StringC, t.UndefinedC]>;
            deployedAt: t.UnionC<[t.StringC, t.UndefinedC]>;
        }>>, t.UndefinedC]>;
    }>;
}>;
declare type ArgoCDAppDetails = t.TypeOf<typeof argoCDAppDetails>;
declare type ArgoCDAppDeployRevisionDetails = t.TypeOf<typeof argoCDAppDeployRevisionDetails>;
declare const argoCDAppList: t.TypeC<{
    items: t.UnionC<[t.ArrayC<t.TypeC<{
        metadata: t.TypeC<{
            name: t.StringC;
            namespace: t.StringC;
            instance: t.UnionC<[t.TypeC<{
                name: t.UnionC<[t.StringC, t.UndefinedC]>;
                url: t.UnionC<[t.StringC, t.UndefinedC]>;
            }>, t.UndefinedC]>;
        }>;
        status: t.TypeC<{
            sync: t.TypeC<{
                status: t.StringC;
            }>;
            health: t.TypeC<{
                status: t.StringC;
            }>;
            operationState: t.UnionC<[t.TypeC<{
                startedAt: t.StringC;
                finishedAt: t.UnionC<[t.StringC, t.UndefinedC]>;
            }>, t.UndefinedC]>;
            history: t.UnionC<[t.ArrayC<t.TypeC<{
                id: t.UnionC<[t.NumberC, t.UndefinedC]>;
                revision: t.UnionC<[t.TypeC<{
                    revisionID: t.UnionC<[t.NumberC, t.UndefinedC]>;
                    author: t.UnionC<[t.NumberC, t.UndefinedC]>;
                    date: t.UnionC<[t.StringC, t.UndefinedC]>;
                    message: t.UnionC<[t.StringC, t.UndefinedC]>;
                }>, t.UndefinedC, t.StringC]>;
                deployStartedAt: t.UnionC<[t.StringC, t.UndefinedC]>;
                deployedAt: t.UnionC<[t.StringC, t.UndefinedC]>;
            }>>, t.UndefinedC]>;
        }>;
    }>>, t.NullC]>;
}>;
declare type ArgoCDAppList = t.TypeOf<typeof argoCDAppList>;
declare const argoCDServiceList: t.ArrayC<t.TypeC<{
    name: t.StringC;
    url: t.StringC;
    appName: t.UnionC<[t.ArrayC<t.StringC>, t.UndefinedC]>;
}>>;
declare type ArgoCDServiceList = t.TypeOf<typeof argoCDServiceList>;

interface ArgoCDApi {
    listApps(options: {
        url: string;
        appSelector?: string;
        appNamespace?: string;
        projectName?: string;
    }): Promise<ArgoCDAppList>;
    getRevisionDetails(options: {
        url: string;
        app: string;
        appNamespace?: string;
        revisionID: string;
        instanceName?: string;
    }): Promise<ArgoCDAppDeployRevisionDetails>;
    getAppDetails(options: {
        url: string;
        appName: string;
        appNamespace?: string;
        instance?: string;
    }): Promise<ArgoCDAppDetails>;
    getAppListDetails(options: {
        url: string;
        appSelector: string;
        appNamespace?: string;
        instance?: string;
    }): Promise<ArgoCDAppList>;
    serviceLocatorUrl(options: {
        appName?: string;
        appSelector?: string;
        appNamespace?: string;
    }): Promise<ArgoCDServiceList | Error>;
}
declare const argoCDApiRef: _backstage_core_plugin_api.ApiRef<ArgoCDApi>;
declare type Options = {
    discoveryApi: DiscoveryApi;
    backendBaseUrl: string;
    searchInstances: boolean;
    identityApi: IdentityApi;
    proxyPath?: string;
    useNamespacedApps: boolean;
};
declare class ArgoCDApiClient implements ArgoCDApi {
    private readonly discoveryApi;
    private readonly backendBaseUrl;
    private readonly searchInstances;
    private readonly identityApi;
    private readonly useNamespacedApps;
    constructor(options: Options);
    getBaseUrl(): Promise<string>;
    getQueryParams(params: {
        [p: string]: string | undefined;
    }): string;
    fetchDecode<A, O, I>(url: string, typeCodec: Type<A, O, I>): Promise<A>;
    listApps(options: {
        url: string;
        appSelector?: string;
        appNamespace?: string;
        projectName?: string;
    }): Promise<{
        items: {
            metadata: {
                name: string;
                namespace: string;
                instance: {
                    name: string | undefined;
                    url: string | undefined;
                } | undefined;
            };
            status: {
                sync: {
                    status: string;
                };
                health: {
                    status: string;
                };
                operationState: {
                    startedAt: string;
                    finishedAt: string | undefined;
                } | undefined;
                history: {
                    id: number | undefined;
                    revision: string | {
                        revisionID: number | undefined;
                        author: number | undefined;
                        date: string | undefined;
                        message: string | undefined;
                    } | undefined;
                    deployStartedAt: string | undefined;
                    deployedAt: string | undefined;
                }[] | undefined;
            };
        }[] | null;
    }>;
    getRevisionDetails(options: {
        url: string;
        app: string;
        appNamespace?: string;
        revisionID: string;
        instanceName?: string;
    }): Promise<{
        author: string | undefined;
        date: string | undefined;
        message: string | undefined;
    }>;
    getAppDetails(options: {
        url: string;
        appName: string;
        appNamespace?: string;
        instance?: string;
    }): Promise<{
        metadata: {
            name: string;
            namespace: string;
            instance: {
                name: string | undefined;
                url: string | undefined;
            } | undefined;
        };
        status: {
            sync: {
                status: string;
            };
            health: {
                status: string;
            };
            operationState: {
                startedAt: string;
                finishedAt: string | undefined;
            } | undefined;
            history: {
                id: number | undefined;
                revision: string | {
                    revisionID: number | undefined;
                    author: number | undefined;
                    date: string | undefined;
                    message: string | undefined;
                } | undefined;
                deployStartedAt: string | undefined;
                deployedAt: string | undefined;
            }[] | undefined;
        };
    }>;
    getAppListDetails(options: {
        url: string;
        appSelector: string;
        appNamespace?: string;
        instance?: string;
    }): Promise<{
        items: {
            metadata: {
                name: string;
                namespace: string;
                instance: {
                    name: string | undefined;
                    url: string | undefined;
                } | undefined;
            };
            status: {
                sync: {
                    status: string;
                };
                health: {
                    status: string;
                };
                operationState: {
                    startedAt: string;
                    finishedAt: string | undefined;
                } | undefined;
                history: {
                    id: number | undefined;
                    revision: string | {
                        revisionID: number | undefined;
                        author: number | undefined;
                        date: string | undefined;
                        message: string | undefined;
                    } | undefined;
                    deployStartedAt: string | undefined;
                    deployedAt: string | undefined;
                }[] | undefined;
            };
        }[] | null;
    }>;
    serviceLocatorUrl(options: {
        appName?: string;
        appSelector?: string;
        appNamespace?: string;
    }): Promise<{
        name: string;
        url: string;
        appName: string[] | undefined;
    }[]>;
}

declare const isArgocdAvailable: (entity: Entity) => boolean;

export { ArgoCDApi, ArgoCDApiClient, EntityArgoCDContent, EntityArgoCDHistoryCard, EntityArgoCDOverviewCard, Options, argoCDApiRef, argocdPlugin, isArgocdAvailable, argocdPlugin as plugin };
